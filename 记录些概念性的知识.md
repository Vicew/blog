---
title: 记录些概念性的知识
date: 2021-03-14 01:38:24
tags: 前端
categories: 前端
---

## DOCTYPE

![定义](http://blog.panxiandiao.com/20210314014735.png)

DTD告诉浏览器这个文件是什么类型，浏览器根据类型来使用什么引擎去渲染他解析他

DOCTYPE告诉浏览器当前文档是哪个DTD

![怎么写DOCTYPE](http://blog.panxiandiao.com/20210314015112.png)

## 运算符优先级

[运算符优先级表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

![来个题](http://blog.panxiandiao.com/20210314230147.png)

```js
function Foo () {
    getName = function() {console.log(1)}
    return this
}
Foo.getName = function() {console.log(2)}
Foo.prototype.getName = function() {console.log(3)}
var getName = function() {console.log(4)}
function getName () {console.log(5)}

Foo.getName()
getName()
Foo().getName()
getName()
new Foo.getName()
new Foo().getName()
new new Foo().getName()
```

new 无参数列表的时候可以省略括号 看着优先级去解决问题

## new

- 创建一个新的对象
- 继承父类原型上的方法. Object.creat(obj.prototype)
- 添加父类的属性到新的对象上并初始化. 保存方法的执行结果. apply(..., args)
- 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象。

```js
function _new(obj, ...rest){
  // 基于obj的原型创建一个新的对象
  const newObj = Object.create(obj.prototype);

  // 添加属性到新创建的newObj上, 并获取obj函数执行的结果.
  const result = obj.apply(newObj, rest);

  // 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象
  return typeof result === 'object' ? result : newObj;
}
```

## String & new String()

```js
var str = "string"
var str2 = String("string")
var str3 = new String("string")
```

第一种和第二种是相同的。第三种严格意义上讲不算是声明字符串，而是使用 String 生成一个 object

> String 全局对象是一个用于字符串或一个字符序列的构造函数。

可以看到，String 的本质是一个函数。String(thing) 将 thing 变成一个字符串并返回。

CPU读内存，内存读磁盘

可以不要磁盘只要内存吗？不行，断电会丢失，磁盘可以持久性存储，ctrl+s就是把内存里的东西保存到磁盘中

## 来一题

```js
;(function b() {
  b = 123
  console.log(b)
})()
```

正常思路：首先这个立即执行函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。执行到`b = 123`赋值语句时，会根据词法作用域规则找到b的声明，并且赋值为123，找到b函数的声明，把他覆盖，所以`console.log(b)`打印123。但是肯定是错误的

正确思路：

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。

2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。（可以理解为在 strict 模式下会报错，非 strict 模式下静默失败的const）当`b = 123`要把常量b覆盖调时，会静默失败。

3. IIFE中的函数是函数表达式，而不是函数声明。

所以还是打印函数