---
title: 记录一些有意思的问题
date: 2019-06-05 23:29:39
tags: 前端
categories: 前端
---

## 字面量（数组字面量，对象字面量，字符串字面量,函数字面量）

我们都知道在JS中，除了六种基本数据类型，其余全部都是属于对象，那么我们创建一个对象的过程如下

```js
    var obj=new Object()
    obj.a='aaa';
    obj.b='bbb'
    obj.c='ccc'
    obj.c//"ccc"
```

但是我们大部分情况下不用这种方式创建对象，我们用这个方式

```js
    var obj = {
    a:'aaa',//a是属性，'aaa'是属性值
    b:'bbb',
    c:'ccc'
    }
    obj.c//"ccc"
```

我们在创建数组，对象，字符串，函数的时候不需要用`new`操作符

**它省略了构造函数传参初始化这一过程，带来的缺点就是初始化的值都是一致的,(每个实例对象没有自己的特性)**

## 内置对象

[内置对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)

## 关联数组

```js
    var arr=new Array();
    arr["china"]="beijing,niaoling,hulan";
    arr["usa"]="newyork,washington,atlanta";
    arr["japan"]="tokyo";
    alert(arr["china"]);
    alert(arr["japan"]);
    alert(arr[0]);
```

注意上面的`alert(arr[0])`;这一句，它会返回`undifined`。这就意味着，关联数组中，不能再以传统的下标方式来访问数组元素而必须通过元素的名字。

这种通过名字来访问数组元素的形式有可读性高，灵活方便的优势。

## apply,bind的黑魔法

如果一个数组我们已知里面全都是数字，想要知道最大的那个数，由于Array没有max方法，Math对象上有

我们可以根据apply传递参数的特性将这个数组当成参数传入

最终Math.max函数调用的时候会将apply的数组里面的参数一个一个传入，恰好符合Math.max的参数传递方式

这样变相的实现了数组的max方法。min方法也同理

```js
    const arr = [1,2,3,4,5,6]
    const max = Math.max.apply(null, arr)
    console.log(max)    // 6
```

如果你想将某个函数绑定新的`this`指向并且固定先传入几个变量可以在绑定的时候就传入，之后调用新函数传入的参数都会排在之后

```js
    const obj = {}
    function test(...args) {console.log(args)}
    const newFn = test.bind(obj, '静态参数1', '静态参数2')
    newFn('动态参数3', '动态参数4')
```

当我们使用一个函数需要改变this指向的时候才会用到call apply bind

## 可以定义一个没有单位的值作为缩放因子来统一控制行高，缩放因子是直接继承的，而不是继承计算值

```html
    <div style="background:#ddd;height:100px;line-height:1.8;font-size:15px;">
        <p style="font-size: 30px;">
            中文 English<br/>
            中文 English
        </p>
    </div>
```

如果line-height有em或者百分比单位

```html
    <div style="background:#ddd;height:100px;line-height:180%;font-size:15px;">
        <p style="font-size: 30px">
            中文 English<br/>
            中文 English
        </p>
    </div>
```

这里div的行高为180%*15px=27px

而p的行高为计算后的27px 而非180%*30px=54px

通过上面的例子我们知道文本之间的空白距离不仅仅是行高决定的，同时也受字号的影响

如果继承的是计算值，那么当元素内的文字字体尺寸不一样的时候，就有可能造成字体的重叠

## 并发和并行

并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发

并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行

## 原始数据类型的bug

六种原始数据类型：`boolean,null,undefined,number,string,symbol`,存储的都是值，是没有函数可以调用的，比如`undefined.toString()`

此时你肯定会有疑问，这不对呀，明明 `'1'.toString()` 是可以使用的。其实在这种情况下，'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数

另外对于 null 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来

## get 和 post

GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同

GET产生一个TCP数据包；POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

## [] == ![] 结果为true

[] == ![] 的判断本质上是原始类型和引用类型的判断，一元运算符 ! 优先级高于二元运算符 ==，实际 == 判断时表达式已经转为 [] == false，然后 == 导致的隐式转换，二者都转为数值 0 == 0 就返回 true 了