---
title: Linux入门必备知识
date: 2019-05-04 12:27:39
tags: Linux
categories: Linux
---

## Linux和Windows的不同

- `Linux`严格区分大小写

- `Linux`中所有内容以文件形式保存，包括硬件

- `Linux`不靠扩展名区分文件类型，但是有约定俗成的扩展名，如
   1. 压缩包：`*.gz` `*.bz2` `*.tat.bz2` `*.tgz` 等
   2. 二进制软件包：`.rpm`
   3. 网页文件：`*.html` `*.php`
   4. 脚本文件：`*.sh`
   5. 配置文件：`*.conf`

## 字符界面的优势

- 字符界面占用的系统资源更少

- 字符界面减少了出错、被攻击的可能性

## 命令格式

命令 [选项] [参数]

**注意：个别命令 使用不遵循此格式，当有多个选项时，可以写在一起，简化选项与完整选项，比如`-a`等于`--all`**

### 起始符的理解

![24](http://blog.panxiandiao.com/24.jpg)

1. root: 当前登录用户（这里也就是管理员）

2. MyHost: 主机的名字

3. ~ ：当前所在的目录（Home目录）

4. #: 超级用户的提示符（普通用户的提示符是$）

### 查询目录中内容：ls

用法： ls [选项] [文件或目录]

选项：

- -a 显示所有文件，包括隐藏文件
- -l 显示详细信息
- -d 查看目录属性
- -h 人性化显示文件大小
- -i 显示inode

接下来解释`ls -l`命令下每一列输出的含义（`ll` = `ls -l`）

![25](http://blog.panxiandiao.com/25.jpg)

第一列代表这个文件的权限，总共有十位

- 第一位代表文件类型（-代表文件，d代表目录，l代表软链接文件，当然还有块设备文件、字符设备文件、套接字文件和管道文件，但是这些都是系统的特殊文件我们一般不做操作）
- 后面九位每三位为一组，代表文件的所有者，分别代表所有者，所属组，其他人，为了分配权限，`r`代表读，`w`代表写，`x`代表执行。举个例子，我购买了一台电脑我是这个电脑的所有者，接电脑给几个朋友玩，这几个朋友就是所属组，其他不能玩我电脑的人就是其他人

第三四五列分别代表所有者，所属组，其他人

![26](http://blog.panxiandiao.com/26.jpg)

第二列我们把它称为引用计数，代表文件被调用过几次

![27](http://blog.panxiandiao.com/27.jpg)

时间的列代表文件最后被修改的时间

### 建立目录：mkdir

用法： mkdir -p [目录名]

英文原意：make directories

-p 递归创建在我们建立二级目录时要用到

![28](http://blog.panxiandiao.com/28.jpg)

### 切换所在目录：cd

用法： cd [目录]

英文原意：change directory

简化操作：

- cd ~ 进入当前用户的家目录
- cd 进入当前用户的家目录
- cd - 进入上次目录
- cd .. 进入上一级目录
- cd . 进入当前目录

相对路径：参照当前所在的目录进行查找（可能查找失败）

绝对路径：从根目录开始指定，一级一级的递归查找。在任何目录下，都能进入指定位置（一定查找成功）

**`pwd`命令查询当前所在哪个目录下**

**输入目录文件时可以按下`Tab`键进行补全，如果没反应再次按下会显示当前所有目录文件或者对应你输入的目录文件**

### 删除文件或目录：rm

用法： rm -rf [文件或者目录]

英文原意：remove

选项：

- -r 删除目录（会有再次确认信息）
- -f 强制（无提示）

### 复制命令：cp

用法： cp [选项] [源文件或目录] [目标目录]

复制并且改名用法： cp [选项] [源文件或目录] [目标目录] []

英文原意：copy

选项：

- -f 复制目录
- -p 连带文件属性复制
- -d 若源文件是链接文件，则复制链接属性
- -a 相当于 -pdr（所有内容属性全部一样，包括时间）

### 剪切或者改名命令：mv

不同目录为剪切： mv [原文件或目录] [目标目录]

英文原意： move

相同目录为改名： mv [原文件或目录] [自定义名字]

## 常见目录的作用

![29](http://blog.panxiandiao.com/29.png)

![30](http://blog.panxiandiao.com/30.png)

根目录下的`bin`和`sbin`,`usr`目录下的`bin`和`sbin`，这四个目录都是用来保存系统命令的

**两个`bin`目录下的命令所有人都可以执行，两个`sbin`目录下的命令则是超级用户才能执行，`Linux`是这样的方法来区分用户权限的**

![31](http://blog.panxiandiao.com/31.png)

系统的启动目录，不能随便操作，写满的话系统跑不起来

![32](http://blog.panxiandiao.com/32.png)

特殊文件保存目录，里面大部分都是硬件文件，不能随便操作

![33](http://blog.panxiandiao.com/33.png)

系统默认的配置文件的目录，后面学习一些服务的时候讲多次运用到这个目录

![34](http://blog.panxiandiao.com/34.png)

`home`是普通用户的家目录，`root`是超级用户的家目录

![35](http://blog.panxiandiao.com/35.png)

`lib`是我们`Linux`中函数库的保存位置，在操作系统中，并不是把所有的功能全部写到了`Linux`当中，他把一些常用的功能写成了一个个程序库，都保存在`lib`下，有需要直接调用即可，免得全部写在`Linux`中让`Linux`显得很笨重并且缓慢

**以上目录对新手来讲不需要来进行操作**

![36](http://blog.panxiandiao.com/36.png)

这两个目录是空目录，我们无论在什么系统中，存储软件只有在挂载之后才能使用，挂载我们可以当做分配盘符，系统给你空目录就是作为你外接存储设备的盘符，`media`是用来挂光盘的，`mnt`是用来挂U盘的

![37](http://blog.panxiandiao.com/37.png)

`proc`和`sys`目录类似，这两个目录保存的是内存的过载点，也就是说这两个目录是内存的盘符，这两个目录中的数据直接写在了内存当中，假设系统重启，数据就会丢失，如果写的数据占满内存，那么系统就会崩溃，所以不能直接操作

![38](http://blog.panxiandiao.com/38.png)

`tmp`是临时目录，有一些临时数据可以放在这里

`var`是系统相关文档内容平

## 搜索命令

### locate

用法： locate [文件名]

在/var/lib/mlocatez（locate数据库）中进行搜索，不需要遍历整个操作系统

**这个数据库不是实时更新的，大约是一天更新一次，如果你创建了一个目录或者文件你需要执行`updatedb`来更新数据库**

**`locate`命令的好处是搜索速度快，缺点是只能按照文件名进行搜索，不能搜索更加复杂的内容**

`locate`是按照配置文件来进行搜索的，我们编辑`/etc/updatedb.conf`里面看看

![41](http://blog.panxiandiao.com/41.png)

- `PRUNE_BIND_MOUNTS = "yes"`代表开启搜索限制
- `PRUNEFS =`代表搜索时，不搜索的文件系统
- `PRUNENAMES =` 代表搜索时，不搜索的文件类型
- `PRUNEPATHS =` 代表搜索时，不搜索的路径

### find

**这个命令十分强大，功能比`Windows`搜索项要多得多，但是选项参数等会比较多**

用法： find [搜索范围] [搜索条件] [搜索文件]

我们来试一下搜索`install.log`文件

![48](http://blog.panxiandiao.com/48.png)

我们会在搜索的过程中发现这条命令执行的时间特别就久，因为搜索范围是整个根目录，所以我们要避免大范围搜索，会非常耗费系统资源

那么当我们不怎么记得要搜索文件的名字的时候，进行模糊查询，我们需要使用通配符，不适用通配符搜索出来的文件和你输入的文件是完全匹配的

- `*`  匹配任意内容
- `?`  匹配任意一个字符
- `[]` 匹配任意一个中括号内的字符

**注意要把输入的内容用双引号括起来，否则不能识别**

![49](http://blog.panxiandiao.com/49.png)

我们在当前目录下创建`abc`和`abd`文件

![50](http://blog.panxiandiao.com/50.png)

当然我们可以混合使用

![51](http://blog.panxiandiao.com/51.png)

代表的是搜索以`c`结尾，以`d`结尾的文件

当然`find`还有其他用法

- find /root -iname install.log (不区分大小写在`root`目录下查找`install.log`文件)
- find /root -user root(按照所有者搜索，其实`root`目录下所有的文件所有者都是`root`)
- find /root -nouser(查找没有所有者的文件，这样的文件对于系统来说就是垃圾文件，但是Linux中有特殊情况，比如内核产生的文件，他是直接调用不经过系统用户，所以产生的文件不一定会有所有者)
- find /var/log/ -mtime +10(查找`10`天前在日志目录下修改的文件，`-10`代表十天内修改文件，`10`代表十天当天修改的文件，`+10`代表十天前修改的文件，`atime`代表文件访问时间，`ctime`代表文件属性，`mtime`代表修改文件内容)
- find . -size 25k（查找当前目录下文件大小是`25KB`的文件，`-25k`代表小于`25KB`的文件，`25k`代表等于`25KB`的文件，`+25k`代表大于`25KB`的文件）
- find . -inum 262422(查找当前目录下`i节点`是`262422`的文件)
- find /etc -size +20k -a -size -50k(查找`/etc/`目录下，大于`20KB`并且小于`50KB`的文件，`-a and` 逻辑与，两个条件都满足，`-o or` 逻辑或，两个条件满足一个即可)
- find /etc -size +20k -a -size -50k -exec ls -lh {} \;(查找/etc/目录下，大于20KB并且小于50KB的文件，并显示详细信息，-exec/-ok命令{}\;对搜索结果执行操作)

### grep

在文件当中匹配符合条件的字符串

用法： grep [选项] [字符串] [文件名]

选项：

- -i 忽略大小写
- -v 排除指定字符串

在文件中找到有包含输入字符串的行输出（若选项是`-v`那么就是没有包含字符串的行）

![52](http://blog.panxiandiao.com/52.jpg)

**`find`命令与`grep`命令的区别**

- find命令： 在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配
- grep命令： 在文件当中搜索符合条件的字符串如果需要匹配，使用正则表达式进行匹配，正则表达式是包含匹配

## 帮助命令

- 获取指定命令的帮助

用法： man 命令

我们来看看`ls`的帮助

![53](http://blog.panxiandiao.com/53.jpg)

我们发现第一行`LS(1)`，这是`man`的帮助级别

1. 查看命令的帮助
2. 查看可被内核调用的函数的帮助
3. 查看函数和函数库的帮助
4. 查看特殊文件的帮助（主要是`/dev`目录下的文件）
5. 查看配置文件的帮助
6. 查看游戏的帮助
7. 查看其他杂项的帮助
8. 查看系统管理员可用命令的帮助
9. 查看和内核相关文件的帮助

- 有些命令当然不止一个帮助，查看命令拥有哪些级别的帮助

`man -f 命令` 相当于 `whatis 命令`

![54](http://blog.panxiandiao.com/54.jpg)

查看哪个级别的帮助文件把`f`改成级数就可以了

**这时候你们有没有发现这个命令跟我们之前学的`whereis`命令很像？**

![55](http://blog.panxiandiao.com/55.jpg)

**其实完全可以用`whereis`去判断命令有哪些帮助文件**

- 查看和命令相关的所有帮助

`man -K 命令` 相当于 `apropos 命令`

![56](http://blog.panxiandiao.com/56.jpg)

只要在帮助文档里出现我们输入的命令相关的关键字，全部都会列出来

## 其他帮助命令

- 命令 --help

![57](http://blog.panxiandiao.com/57.jpg)

在只想看选项帮助，不看其他信息用这个命令

- help shell内部命令

获取`shell`内部命令的帮助,外部命令用这个命令会报错

> `Shell` 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务

上面我们已经说过，`cd`这个命令没有可执行文件，就是说`cd`就是这个界面自带的一个简单命令

- 详细命令帮助`info 命令`
   1. 回车：进入子帮助页面（带有*号标记）
   2. u:进入上层页面
   3. n:进入下一个帮助小节
   4. p:进入上一个帮助小节
   5. q:退出

**实际上这个命令里面的内容是系统把所有命令的帮助写成了一个巨大的文档，操作较麻烦，了解一下就行0**

## 压缩与解压缩命令

### .zip格式压缩和解压缩

- zip [压缩文件名] [源文件] （压缩文件）

- zip -r [压缩文件名] [源目录] （压缩目录）

**压缩文件名虽然可以不写后缀名（`Linux`不区分扩展名）但是你要认出你压缩出来的文件是压缩文件，所以最好加上后缀**

- unzip [压缩文件]
  
  解压缩`.zip`文件（解压缩文件和解压缩目录一样）

### .gz格式压缩和解压缩

- gzip [源文件] (压缩为`.gz`格式的压缩文件，源文件会消失)

- gzip -c [源文件] > [压缩文件] (压缩为.gz格式，源文件保留)

- gzip -r [目录] (压缩目录下所有的子文件，但是不能用压缩目录)

- gzip -d [压缩文件] 或者 gunzip [压缩文件] (解压缩)

### .bz2格式压缩和解压缩

- bzip2 [源文件] (压缩为`.bz2`格式，不保留源文件)

- bzip2 -k [源文件] (压缩之后保留源文件)

**`bzip2`命令不能压缩目录**

- bzip2 -d [压缩文件] (解压，`-k`保留压缩文件)
- bunzip2 [压缩文件] (解压，`-k`保留压缩文件)

### 打包命令tar和解打包

**`.gz`和`.bz2`都对目录压缩都多少有问题，所以我们引出打包命令`tar`,把目录压成一个文件包那么就可以进行压缩**

用法： tar -cvf [打包文件名] [源文件]

选项：

- -c : 打包
- -v : 显示过程
- -f : 指定打包后的文件名

- tar -xvf [打包文件名]（`-x`代表解打包）

**其实`.tar.gz`格式不用一步步来先打包为`.tar`格式，在压缩为`.gz`格式，可以直接输入`tar -zcvf [压缩报名].tar.gz 源文件`即可压缩成`.tar.gz`格式，解压缩命令把`-c`改成`-x`即可。同理`.tar.bz2`压缩方法和解压缩方法把`-z`改成`-j`即可**

## 关机和重启命令

用法: shutdown [选项] [时间]

选项：

- -c:取消前一个关机命令
- -h:关机
- -r:重启

时间的值可以`now`代表立马关机，也可以是一个具体的时间，代表系统在你指定的时间关机，我们假定指定凌晨`5：30`关机，我们会发现一个问题，会卡着操作不了了

![58](http://blog.panxiandiao.com/58.png)

按下`ctrl+c`终止退出，这时候我们可以在那条命令后面加一个后台符`&`，代表后台运行，如果想让后台这个任务终止，可以执行`shutdown -c`终止任务

> 还有 `halt` `poweroff` `init 0`命令可以也能关机，这几个了解就好，远不如`shutdown`安全，极易造成文件丢失。`reboot``init 6`也可以进行重启第一个较安全

刚刚我们看到`init 0`和`init 6`这个`0`和`6`是系统的运行级别

- 0 关机
- 1 单用户（相当于`Windows`中的安全模式，进如系统修复的时候）
- 2 不完全多用户，不含NFS服务（NFC：文件共享服务）
- 3 完全多用户（就是我们目前使用的字符界面）
- 4 未分配
- 5 图形界面
- 6 重启

我们用`runlevel`查询当前系统运行级别

![59](http://blog.panxiandiao.com/59.png)

`N`代表上一次所在级别，`3`代表目前所在级别，这里的意思是到现在系统一直是`3`级别

假设我们系统刚开始既装了图形界面和字符界面，那么我们如何控制打开时用的是什么级别的系统呢

```Linux
    cat/etc/inittab
```

![60](http://blog.panxiandiao.com/60.png)

修改对应级数即可（**切记不能把级数写成零或者六，系统一开机就会关机或者一开机就会重启**）

退出登录命令我们输入`logout`即可