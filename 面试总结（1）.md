---
title: 面试总结（1）
date: 2019-07-28 23:04:29
tags: 前端
categories: 前端
---

## div长宽固定，包裹在内的图片长宽不知，如何让图片水平垂直居中

`flex布局`，`绝对定位margin:auto`,`transform属性` 。。。。。。

说完还不够，面试官问你题目特地说了图片长宽不知，会不会有什么问题？会不会有图片实际长宽比div定的长宽大？是不是就居中不了了？这时候只能用`background-image`来实现了

## jsonp是如何解决跨域问题的

利用`<script>`标签没有跨域限制的“漏洞”来达到与第三方通讯的目的(就这么简单)

## 谈谈vuex的状态管理模式

通俗来讲，vuex是把所有组件中的所有状态和数据放在同一个内存空间去管理，称作`state`，里面的数据方便映射到我们的组件上去渲染组件，当组件的数据发生变化时，可以通过`Dispatch`一个`Action`(可以做一些异步的操作和后台的交互)，然后`commit`一个`Mutations`当然可以直接通过组件来`commit`一个`Mutations`，也只有唯一的这个途径我们才能修改`State`，其他任何方式修改都是非法的，Vuex这样子设计的目的就是让这个修改变得可以预测，形成闭环。平常我们在vue中，数据的变化直接映射到dom的变化，在vuex中不行。虽然修改路径会变长，但是也解决了复杂项目兄弟组件的共享数据问题，和多个组件数据连通的高耦合等问题。也可以解决路由间的复杂数据传递的场景。

## 钩子函数

![钩子函数](http://blog.panxiandiao.com/20190730170635.png)

[起步理解](https://juejin.im/post/5ad10800f265da23826e681e)

[深入理解](https://juejin.im/post/5b41bdef6fb9a04fe63765f1)

## 服务端渲染

简单理解是将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。于传统的SPA（单页应用）相比，服务端渲染能更好的有利于SEO，减少页面首屏加载时间，当然对开发来讲我们就不得不多学一些知识来支持服务端渲染。同时服务端渲染对服务器的压力也是相对较大的，和服务器简单输出静态文件相比，通过node去渲染出页面再传递给客户端显然开销是比较大的，需要注意准备好相应的服务器负载。

你可以在引一下SPA,SEO

SPA是一种 网络应用程序(WebApp)模型。在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而在SPA这个模型中，是通过动态地重写页面的部分与用户交互，而避免了过多的数据交换，响应速度自然相对更高。当切换到新的页面，只需要重写页面发生了变化的部分。

搜索引擎优化。SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。

前面我们谈到的SPA不利于SEO，因为就目前而言，部分搜索引擎如Google、bing等，它们的爬虫虽然已经支持执行JS甚至是通过AJAX获取数据了，但是对于异步数据的支持也还不足(也可能是搜索引擎提供商觉得没必要)，Vue SSR中是这样说的

如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。

前面也谈到过SPA应用中，通常通过AJAX获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行JS和通过AJAX获取数据，那就更不用提SEO了。

## 伪元素和伪类

伪类其实是弥补了CSS选择器的不足，用来更方便地获取信息（`:first-child`，`:last-child`）（获取列表的子项）

而伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式(`::before`,`::after`)(去除浮动)

在CSS3中，伪类用单冒号:表示；而伪元素用双冒号::表示。一个选择器可以同时使用多个伪类(但有的伪类会互斥)；而一个选择器只能同时使用一个伪元素(未来的版本可能会支持多伪元素)

## MVVM

`Model-View-ViewModel` 就是将其中的 `View` 的状态和行为抽象化，让我们可以将UI和业务逻辑分开。当然这些工作 `ViewModel` 已经帮我们做了，它可以取出 `Model` 的数据同时帮忙处理 `View` 中由于需要展示内容而涉及的业务逻辑。

- Model - 包含了业务和验证逻辑的数据模型
- View - 定义屏幕中View的结构，布局和外观
- ViewModel - 扮演“View”和“Model”之间的使者，帮忙处理 View 的全部业务逻辑

MVVM模式和MVC有些类似，但有以下不同：

- ViewModel 替换了 Controller，在UI层之下
- ViewModel 向 View 暴露它所需要的数据和指令对象
- ViewModel 接收来自 Model 的数据

你可以看到这两种模式有着相似的结构，但新加入的 ViewModel 是用不同的方法将组件们联系起来的，它是双向的，而MVC只能单向连接。

概括起来，MVVM是由MVC发展而来 - 通过在 Model 之上而在 View 之下增加一个非视觉的组件将来自 Model 的数据映射到 View 中