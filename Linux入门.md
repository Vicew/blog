---
title: Linux入门
date: 2019-05-04 12:27:39
tags: Linux
categories: Linux
---

## Linux和Windows的不同

- `Linux`严格区分大小写

- `Linux`中所有内容以文件形式保存，包括硬件

- `Linux`不靠扩展名区分文件类型，但是有约定俗成的扩展名，如
   1. 压缩包：`*.gz` `*.bz2` `*.tat.bz2` `*.tgz` 等
   2. 二进制软件包：`.rpm`
   3. 网页文件：`*.html` `*.php`
   4. 脚本文件：`*.sh`
   5. 配置文件：`*.conf`

## 字符界面的优势

- 字符界面占用的系统资源更少

- 字符界面减少了出错、被攻击的可能性

## 命令格式

命令 [选项] [参数]

**注意：个别命令 使用不遵循此格式，当有多个选项时，可以写在一起，简化选项与完整选项，比如`-a`等于`--all`**

### 起始符的理解

![24]()

1. root: 当前登录用户（这里也就是管理员）

2. MyHost: 主机的名字

3. ~ ：当前所在的目录（Home目录）

4. #: 超级用户的提示符（普通用户的提示符是$）

### 查询目录中内容：ls

用法： ls [选项] [文件或目录]

选项：

- -a 显示所有文件，包括隐藏文件
- -l 显示详细信息
- -d 查看目录属性
- -h 人性化显示文件大小
- -i 显示inode

接下来解释`ls -l`命令下每一列输出的含义（`ll` = `ls -l`）

![25]()

第一列代表这个文件的权限，总共有十位

- 第一位代表文件类型（-代表文件，d代表目录，l代表软链接文件，当然还有块设备文件、字符设备文件、套接字文件和管道文件，但是这些都是系统的特殊文件我们一般不做操作）
- 后面九位每三位为一组，代表文件的所有者，分别代表所有者，所属组，其他人，为了分配权限，`r`代表读，`w`代表写，`x`代表执行。举个例子，我购买了一台电脑我是这个电脑的所有者，接电脑给几个朋友玩，这几个朋友就是所属组，其他不能玩我电脑的人就是其他人

第三四五列分别代表所有者，所属组，其他人

![26]()

第二列我们把它称为引用计数，代表文件被调用过几次

![27]()

时间的列代表文件最后被修改的时间

### 建立目录：mkdir

用法： mkdir -p [目录名]

英文原意：make directories

-p 递归创建在我们建立二级目录时要用到

![28]()

### 切换所在目录：cd

用法： cd [目录]

英文原意：change directory

简化操作：

- cd ~ 进入当前用户的家目录
- cd 进入当前用户的家目录
- cd - 进入上次目录
- cd .. 进入上一级目录
- cd . 进入当前目录

相对路径：参照当前所在的目录进行查找（可能查找失败）

绝对路径：从根目录开始指定，一级一级的递归查找。在任何目录下，都能进入指定位置（一定查找成功）

**`pwd`命令查询当前所在哪个目录下**

**输入目录文件时可以按下`Tab`键进行补全，如果没反应再次按下会显示当前所有目录文件或者对应你输入的目录文件**

### 删除文件或目录：rm

用法： rm -rf [文件或者目录]

英文原意：remove

选项：

- -r 删除目录（会有再次确认信息）
- -f 强制（无提示）

### 复制命令：cp

用法： cp [选项] [源文件或目录] [目标目录]

复制并且改名用法： cp [选项] [源文件或目录] [目标目录] []

英文原意：copy

选项：

- -f 复制目录
- -p 连带文件属性复制
- -d 若源文件是链接文件，则复制链接属性
- -a 相当于 -pdr（所有内容属性全部一样，包括时间）

### 剪切或者改名命令：mv

不同目录为剪切： mv [原文件或目录] [目标目录]

英文原意： move

相同目录为改名： mv [原文件或目录] [自定义名字]

## 常见目录的作用

![29]()

![30]()

根目录下的`bin`和`sbin`,`usr`目录下的`bin`和`sbin`，这四个目录都是用来保存系统命令的

**两个`bin`目录下的命令所有人都可以执行，两个`sbin`目录下的命令则是超级用户才能执行，`Linux`是这样的方法来区分用户权限的**

![31]()

系统的启动目录，不能随便操作，写满的话系统跑不起来

![32]()

特殊文件保存目录，里面大部分都是硬件文件，不能随便操作

![33]()

系统默认的配置文件的目录，后面学习一些服务的时候讲多次运用到这个目录

![34]()

`home`是普通用户的家目录，`root`是超级用户的家目录

![35]()

`lib`是我们`Linux`中函数库的保存位置，在操作系统中，并不是把所有的功能全部写到了`Linux`当中，他把一些常用的功能写成了一个个程序库，都保存在`lib`下，有需要直接调用即可，免得全部写在`Linux`中让`Linux`显得很笨重并且缓慢

**以上目录对新手来讲不需要来进行操作**

![36]()

这两个目录是空目录，我们无论在什么系统中，存储软件只有在挂载之后才能使用，挂载我们可以当做分配盘符，系统给你空目录就是作为你外接存储设备的盘符，`media`是用来挂光盘的，`mnt`是用来挂U盘的

![37]()

`proc`和`sys`目录类似，这两个目录保存的是内存的过载点，也就是说这两个目录是内存的盘符，这两个目录中的数据直接写在了内存当中，假设系统重启，数据就会丢失，如果写的数据占满内存，那么系统就会崩溃，所以不能直接操作

![38]()

`tmp`是临时目录，有一些临时数据可以放在这里

`var`是系统相关文档内容平

## 链接命令

用法： ln -s [源文件] [目标文件]

英文原意：link

功能描述：生成链接文件

选项： -s 创建软链接

### 硬链接

1. 拥有相同的`i`节点和存储`block`块，可以看做是同一个文件
2. 可通过`i`节点识别
3. 不能跨分区
4. 不能针对目录使用

一个分区要想使用，要把它分成等大小的`block`数据块，在分区之前会有分区表，给每个文件建一行相关数据，保存了`i`节点号，修改的时间以及存储的位置

![39]()

如图：比如一个用户想要知道`A`文件，他不是直接到硬盘中去取数据，而是会先去搜索分区表，然后确定到`i`节点号，来确定文件的这一行数据，然后根据存储位置来读取到硬盘中的数据

假设我给`A`文件创建了一个硬链接`B`，`B`和`A`有相同的`i`节点号，那么他们的内容也肯定是相同的，也就是说他们两个就是一模一样的文件，只不过名字不一样

**我们不建议使用硬链接，首先是很难区分，其次限制较多，很容易产生错误**

### 软链接

1. 类似`Windows`快捷方式
2. 软链接拥有自己的`i`节点和`Block块`，但是数据块中只保存原文件的文件名和`i`节点号，并没有实际的文件数据
3. 软链接文件权限都为rwxrwxrwx
4. 修改任意文件，另一个都改变
5. 删除原文件，软链接不能使用

![40]()

同样的我们为`A`创建一个软链接`B`，这时候`B`是有自己的`i`节点号,时间，存储的位置的,当然也有对应的数据块，但是这个数据块里面保存的是`A`的`i`节点号，时间，存储位置，所以在通过这个来读取原始数据，所以和这个原理和`Windows`快捷方式的原理一模一样，比如我们创建了桌面的某个文件的快捷方式，通过这个快捷方式找到原文件在执行。如果我们修改`A`，软链接就会找不到`B`所指的`A`的`i`节点，就不能使用了

## 搜索命令

### locate

用法： locate [文件名]

在/var/lib/mlocatez（locate数据库）中进行搜索，不需要遍历整个操作系统

**这个数据库不是实时更新的，大约是一天更新一次，如果你创建了一个目录或者文件你需要执行`updatedb`来更新数据库**

**`locate`命令的好处是搜索速度快，缺点是只能按照文件名进行搜索，不能搜索更加复杂的内容**

`locate`是按照配置文件来进行搜索的，我们编辑`/etc/updatedb.conf`里面看看

![41]()

- `PRUNE_BIND_MOUNTS = "yes"`代表开启搜索限制
- `PRUNEFS =`代表搜索时，不搜索的文件系统
- `PRUNENAMES =` 代表搜索时，不搜索的文件类型
- `PRUNEPATHS =` 代表搜索时，不搜索的路径

### 搜索命令的命令

#### whereis 命令名

作用是搜索命令所在路径及帮助文档所在位置

选项:

- -b: 只查找可执行文件
- -m: 之查找帮助文件

我们查一下ls命令的具体信息

![42]()

左边的就是命令所在的路径，右边的就是帮助文档

#### which 文件名

作用是搜索命令所在路径及别名

我们看看ls

![43]()

第一行代表我们实际执行的是`ls --color=auto`表示`ls`会支持颜色显示，显示方案是自动显示

第二行就是命令的路径

**并不是所有的命令都有别名，所以只会显示命令的路径**

**还有些命令既没有别名又不存在路径，比如`cd`他是`linux`中的`shell`的内置文件后面的博客会详细讲**

那我们来理解一下`cd`不在这些目录这句话的含义，我们首先理解一下**环境变量**

![44]()

在`linux`中，要想执行脚本，执行文件，执行命令，只有一种方法，就是用绝对路径，刚刚我们查到了`ls`命令在`bin`目录下，也就是说我们要打`bin`下的`ls`才能执行

![45]()

但是这样做很不方便，所以系统给我们开发出了`PATH`环境变量，就是我们定义用户操作环境的变量，比如我们`Windows`用户定义分辨率，桌面背景，这些都是操作环境。我们输入`echo $PATH`来显示当前的环境变量

![46]()

该变量的值由一系列以冒号分隔的目录名组成，如果我们执行ls命令，并且在当前目录下找不到ls命令的执行文件或者脚本，那么他就会在PATH指定的路径中去搜索，看看有没有哪个目录下会有，在/bin 目录下找到了，成功执行。如果所有路径下都没找到，那么就是命令不存在

![47]()

### find

**这个命令十分强大，功能比`Windows`搜索项要多得多，但是选项参数等会比较多**

