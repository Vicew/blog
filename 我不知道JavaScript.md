---
title: 我不知道的JavaScript-作用域和闭包
date: 2020-07-23 14:21:39
tags: JavaScript
categories: JavaScript
---

如题，这是我第二次阅读《你不知道的JavaScript》，记录我所不知道的JavaScript和补充相关知识   （确实是我不太知道的）

## 编译原理

程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”

- 分词/词法分析（Tokenizing/Lexing）

这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。

> 分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简
  单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。(区别我看的云里来雾里去，我去查阅了资料，并不能解决当前的疑惑，并且他们的结论是分词和词法分析指的是同一件事情)

- 解析/语法分析（Parsing）

这里推荐一个AST生成器的网址[点此进](https://astexplorer.net/)

这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。例如var a = 2; 我们看看AST长什么样子吧

![AST](http://blog.panxiandiao.com/20200723152406.png)

- 代码生成

AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。

抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。

比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等

因此在这里只进行宏观、简单的介绍，接下来你就会发现我们介绍的这些看起来有点高深
的内容与所要讨论的事情有什么关联。

首先，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因
为与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。

对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时
间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 JIT，可以延
迟编译甚至实施重编译）来保证性能最佳。

简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此，
JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且
通常马上就会执行它。

## 理解作用域

我们对要参与到对程序 var a = 2; 进行处理的过程中的演员们进行介绍

- 引擎

从头到尾负责整个 JavaScript 程序的编译及执行过程

- 编译器

引擎的好朋友之一，负责语法分析及代码生成等脏活累活

- 作用域

引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查
询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

为了能够完全理解 JavaScript 的工作原理，你需要开始像引擎（和它的朋友们）一样思考，
从它们的角度提出问题，并从它们的角度回答这些问题

当你看见 var a = 2; 这段程序时，很可能认为这是一句声明。但我们的新朋友引擎却不这
么看。事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一
个则由引擎在运行时处理

下面我们将 var a = 2; 分解，看看引擎和它的朋友们是如何协同工作的。

编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编
译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。

可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内
存，将其命名为 a，然后将值 2 保存进这个变量。”然而，这并不完全正确。

事实上编译器会进行如下处理

1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的
  集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
  用域的集合中声明一个新的变量，并命名为 a
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值
   操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的
   变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（具体参考我另一篇博客最后补充的内容 [点此进](http://www.panxiandiao.com/2019/05/17/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%88%A4%E6%96%AD%20this%EF%BC%9F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%20this%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/#more) ）

如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！

**总结**：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值

为了进一步理解，我们需要多介绍一点编译器的术语

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是
否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查
找结果

在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS

我打赌你一定能猜到“L”和“R”的含义，它们分别代表左侧和右侧

什么东西的左侧和右侧？是一个赋值操作的左侧和右侧

换句话说，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询

讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图
找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋
值操作的右侧”，更准确地说是“非左侧”

你可以将 RHS 理解成 retrieve his source value（取到它的源值），这意味着“得到某某的
值”

让我们继续深入研究。

考虑以下代码：
```js
console.log( a );
```

其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取
得 a 的值，这样才能将值传递给 console.log(..)

相比之下，例如：

```js
a = 2
```

这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 =
2 这个赋值操作找到一个目标

> LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=
  赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最
  好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头
  （RHS）”

考虑下面的程序，其中既有 LHS 也有 RHS 引用

```js
function foo(a) {
console.log( a ); // 2
}
foo( 2 );
```

最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把
它给我”。并且 (..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值！

这里还有一个容易被忽略却非常重要的细节。

代码中隐式的 a＝2 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给
foo(..) 函数时，2 会被分配给参数 a。为了给参数 a（隐式地）分配值，需要进行一次
LHS 查询。

这里还有对 a 进行的 RHS 引用，并且将得到的值传给了 console.log(..)。console.
log(..) 本身也需要一个引用才能执行，因此会对 console 对象进行 RHS 查询，并且检查
得到的值中是否有一个叫作 log 的方法。

最后，在概念上可以理解为在 LHS 和 RHS 之间通过对值 2 进行交互来将其传递进 log(..)
（通过变量 a 的 RHS 查询）。假设在 log(..) 函数的原生实现中它可以接受参数，在将 2 赋
值给其中第一个（也许叫作 arg1）参数之前，这个参数需要进行 LHS 引用查询

看到下面的对话的例子我觉得挺形象生动的（例子还是上面那段js）

引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？

作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。

引擎：哥们太够意思了！好吧，我来执行一下 foo。

引擎：作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？

作用域：这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。

引擎：大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。

引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？

作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。

给你。

引擎：么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。

引擎：哥们，能帮我再找一下对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。

作用域：放心吧，这个变量没有变动过，拿走，不谢。

引擎：真棒。我来把 a 的值，也就是 2，传递进 log(..)。

……

## 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修
改”（也可以说欺骗）词法作用域呢？

JavaScript 中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是
什么好注意。但是关于它们的争论通常会忽略掉最重要的点：欺骗词法作用域会导致性能
下降。

在详细解释性能问题之前，先来看看这两种机制分别是什么原理。

### eval

```js
function foo(str, a) {
eval( str ); // 欺骗！
console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书
写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并
运行，就好像代码是写在那个位置的一样。它是如何通过代码欺骗和假装成书写时（也就是词法期）
                  代码就在那，来实现修改词法作用域环境的，这个原理就变得清晰易懂了。
                  在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插
                  入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找
                  
eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代
码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实
上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽
了外部（全局）作用域中的同名变量（同名屏蔽）

> 在这个例子中，为了展示的方便和简洁，我们传递进去的“代码”字符串是
  固定不变的。而在实际情况中，可以非常容易地根据程序逻辑动态地将字符
  拼接在一起之后再传递进去。eval(..) 通常被用来执行动态创建的代码，因
  为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代
  码写在那里更有好处。

默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函
数），就会对 eval(..) 所处的词法作用域进行修改。技术上，通过一些技巧（已经超出我
们的讨论范围）可以间接调用 eval(..) 来使其运行在全局作用域中，并对全局作用域进行
修改。但无论何种情况，eval(..) 都可以在运行期修改书写期的词法作用域

在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其
中的声明无法修改所在的作用域

```js
function foo(str) {
"use strict";
eval( str );
console.log( a ); // ReferenceError: a is not defined
}
foo( "var a = 2" )
```            

JavaScript 中 还 有 其 他 一 些 功 能 效 果 和 eval(..) 很 相 似。setTimeout(..) 和
setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的
函数代码。这些功能已经过时且并不被提倡。**不要使用它们！**

new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转
化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比
eval(..) 略微安全一些，但也要尽量避免使用

在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损
失

### with

这个关键词我第一次见到是在Vue2.0源码中，最后说一手 📕

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象
本身，比如：

```js
var obj = {
a: 1,
b: 2,
c: 3
};
// 单调乏味的重复 "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
a = 3;
b = 4;
c = 5;
}
```

但实际上这不仅仅是为了方便地访问对象属性。考虑如下代码：

```js
function foo(obj) {
with (obj) {
a = 2;
}
}
var o1 = {
a: 3
};
var o2 = {
b: 3
};
foo( o1 );
console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```

这个例子中创建了 o1 和 o2 两个对象。其中一个具有 a 属性，另外一个没有。foo(..) 函
数接受一个 obj 参数，该参数是一个对象引用，并对这个对象引用执行了 with(obj) {..}。
在 with 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个
LHS 引用（查看第 1 章），并将 2 赋值给它

当我们将 o1 传递进去，a＝2 赋值操作找到了 o1.a 并将 2 赋值给它，这在后面的 console.
log(o1.a) 中可以体现。而当 o2 传递进去，o2 并没有 a 属性，因此不会创建这个属性，
o2.a 保持 undefined

但是可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局的变量 a。这
是怎么回事

with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对
象的属性也会被处理为定义在这个作用域中的词法标识符

> 尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var
  声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作
  用域中。

eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而
with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。

可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含
有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符，
因此进行了正常的 LHS 标识符查找（查看第 1 章）。

o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行
时，自动创建了一个全局变量（因为是非严格模式）

> 另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限
  制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用
  eval(..) 也被禁止了

### 性能

eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词
法作用域。

你可能会问，那又怎样呢？如果它们能实现更复杂的功能，并且代码更具有扩展性，难道
不是非常好的功能吗？答案是否定的。

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的
词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到
标识符。

但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断
都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会
如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底
是什么。

最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简
单的做法就是完全不做任何优化。

如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪
明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代
码会运行得更慢这个事实

## 匿名和具名函数

对于函数表达式你最熟悉的场景可能就是回调参数了，比如：

```js
setTimeout( function() {
console.log("I waited 1 second!");
}, 1000 );
```

这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，
而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的

匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是
它也有几个缺点需要考虑

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，
比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑
自身。
3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让
代码不言自明

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函
数表达式指定一个函数名可以有效解决以上问题。**始终给函数表达式命名是一个最佳实践**

## for循环中的let

```js
for (let i=1; i<=5; i++) {
setTimeout( function timer() {
console.log( i );
}, i*1000 );
}
```

for 循环头部的 let 声明还会有一
个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随
后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

## 闭包

闭包问题请参照 [点此进](http://www.panxiandiao.com/2019/05/21/JS%20%E9%97%AD%E5%8C%85/)